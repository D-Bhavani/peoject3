{
  "name": "jMint",
  "tagline": "Turning dirty hacks into charity",
  "body": "#Overview\r\n## What is jMint?\r\n*jMint* is a tool for injecting a new behavior into running Java application without changing its source code. The behavior is expressed in ordinary Java code; it can be either appending or altering and can be applied to either application or library code.\r\n\r\njMint is not a hacking tool and therefore doesn't contain any facilities to break the protection (if any). It also knows nothing about legal aspects so that before modifying an application or a library please make sure you do not violate its license.\r\n\r\n## What is it for?\r\nTypical use cases of *jMint* include (but not restricted to) testing stage when some custom behavior should not (or even can not) be included into the source code. For example:\r\n- to reproduce complicated cases;\r\n- to include simple stubs/mocks into the app;\r\n- to prevent undesired scenario;\r\n- to add some logging to where it wasn't provided initially, etc;\r\n- _(welcome to add yours one:wink:)_\r\n\r\n## How does it work?\r\njMint operates as Java agent - special kind of application that is launched by JVM and is able to modify byte code of classes being loaded by JVM.\r\n* First, **jMint** loads and parses the modifying behavior in the form of **_droplet_** - Java source file describing the target of modification (class, method, etc) and the modifying code itself _(see next section)_.\r\n* Then, at the time of target class loading the modifying code gets compiled against the class and **jMint** passes it to JVM alongside with the original byte code just like if it was loaded in usual way.\r\n\r\n## What is droplet?\r\n**Droplet** *(in the sense of injection)* is an ordinary Java source code file that is used by **jMint** to find out 2 things:\r\n\r\n1. The target of modification - a place in the application where the modification must be applied;\r\n2. The modifying code itself.\r\n\r\nDroplets look like all other Java type definitions (classes, interfaces, enums) but in fact they are not. Their classes' and methods' signatures do not define anything new, instead they just specify the target of modification.  \r\n:bulb: _**Example.**_ If you have class `com.example.coolapp.Saver` with method `private void save(BusinessEntity entity)` and you want to prepend it with dumping of argument to standard output then your droplet may look like (*Saver.java*):\r\n```java\r\npackage com.example.coolapp;\r\nimport com.example.coolapp.model.BusinessEntity;\r\nclass Saver {\r\n  /** @cutpoint BEFORE */\r\n  void save(BusinessEntity entity) {\r\n    System.out.println(\"Entity to save: \" + entity.toString());\r\n  }\r\n}\r\n```\r\nThis droplet doesn't define a new method `save`. Instead it instructs jMint to find method `com.example.coolapp.Saver#save(com.example.coolapp.model.BusinessEntity)` during class loading and to inject the specified code right before the body of the method.\r\n\r\n***\r\nThe place of insertion relative to target method body is called **cutpoint** and is specified via custom javadoc tag `@cutpoint` which can take one of 3 values:\r\n- `BEFORE` to inject the code right before the target method body.  \r\n_Generally used for manipulating method arguments (including their change) and for preventing execution of the body (possibly depending on arguments values);_\r\n- `INSTEAD` to completely replace the target method body with a new one.  \r\n_Generally used to stub the whole method or to modify just a piece of code buried inside the body._\r\n- `AFTER` to append some code to the end of the target method body.  \r\n*Generally used to manipulate the result value (including its change). When writing modifying code against `AFTER` cutpoint there is a synthetic variable `$_` available which holds current result value.*  \r\n:warning: Note that if method throws an exception the `AFTER` cutpoint's code won't be executed. For this purpose there will be a special cutpoint `CATCH` which is still in development stage.  \r\n:construction: *Please send a feedback (via email or issues) if you really miss this feature.*\r\n\r\nFor more info on droplets see next section.\r\n\r\n## Download\r\nCurrent version: [jmint-1.1.jar](https://github.com/Toparvion/jmint/releases/download/v1.1/jmint-1.1.jar).  \r\n:information_source: Description of current version is available on the [Latest Release page](https://github.com/Toparvion/jmint/releases/latest).\r\n\r\n# Usage\r\nUsage of **jMint** includes two steps:\r\n\r\n1. Create droplet(s);\r\n2. Attach **jMint** to target application for applying created droplet(s).\r\n\r\n## Step 1: Create droplet\r\nThere are 2 general approaches to create a droplet: *from source code of target class* and *from scratch*.  \r\n- The first one is handy when you have source code of a class being modified and you want to apply its slightly changed version at runtime. The **advantage** of this approach is that you don't have to manually write droplet class, you may just copy the existing one and modify the target method(s) only. The **flaw** is that your droplet gets some excess source code (which may be confusing in case of large class _(and may provoke bugs in jMint:wink:)_).\r\n- The second approach is preferable when you don't want to copy the whole original source code and/or want to keep the droplet as simple as possible. The **pros and cons** of this approach are opposite to the first one: it makes you write some code manually but on the other hand it allows you to fill the droplet with the code you really need, without surpluses.\r\n\r\n#### Approach 1. Creating droplet from target class\r\n\r\n1. Make a copy of the target class's source code file with `Droplet` or `_Droplet` suffix (in any case) in the same package, for example `com.example.coolapp.TheAppDroplet` or `com.example.coolapp.TheApp_droplet`.  \r\n:information_source: _If your target class name already ends with `Droplet` just add it again. Only the last one will be omitted._  \r\nThe suffix is needed to distinguish the original class from droplet. It will be omitted by jMint during parsing the droplet. The target type must not necessarily be a class, it can be an enum or an interface (but not annotation) as well as can be inner type on any level.  \r\n:bulb: _In order to prevent accidental committing of droplet to your Version Control System (VCS) add droplets suffix into the list of exclusions. For instance in Git it can be achieved by adding the following line into `.gitignore` file:_\r\n` *Droplet.java`\r\n2. Find the target method(s) in the copied class and make sure it have javadoc description _(a block comment starting with forward slash and double asterisk (`/**`) located just before the method definition)_. If not, add one.\r\n3. Add custom javadoc tag `@cutpoint` with one of values: `BEFORE`, `INSTEAD`, `AFTER`.\r\nIn the simplest case the whole javadoc definition may look like:  \r\n`/** @cutpoint INSTEAD */`\r\n4. In the body of target method write (or change) the code you want to be injected according to selected cutpoint.  \r\n:warning: _Please remember about some limitations of modifying code (see corresponding section below)._\r\nAll other class members will be ignored by jMint.  \r\n5. Repeat steps 2-4 for all the target methods of this class and then save the droplet anywhere you want.\r\n\r\n:bulb: **Example.** Here's a sample droplet created from copy of its target class (_FooDroplet.java_):\r\n```java\r\npackage com.example.coolapp;\r\n\r\nimport com.example.coolapp.model.*;\r\nimport java.lang.util.*;\r\nimport com.example.coolapp.util.Monitored;\r\n\r\n@Monitored\r\npublic class FooDroplet extends FooBase implements Fooable {\r\n  private static final Logger log = LoggerFactory.getLogger(Foo.class);\r\n  /* other fields left from original class */\r\n\r\n  /**\r\n   * Performs fooing with given entity.\r\n   *\r\n   * @param entity an entity to fooify\r\n   * @cutpoint BEFORE\r\n   */\r\n  @Override\r\n  public void fooify(BusinessEntity entity) throws Exception {\r\n    System.out.println(\"Entity to fooify: \" + entity.toString());\r\n  }\r\n\r\n  /* other constructors and methods left from original class */\r\n}\r\n```\r\nAs you can see there is plenty of code that doesn't concerns the droplet. Compare it with code from the next approach.\r\n***\r\n#### Approach 2. Creating a droplet from scratch\r\n1. Create a text file with name `<TargetClassSimpleName>Droplet.java` in any directory.  \r\n:information_source: _This name format is just a kind of best practice; you may give the file any name._\r\n2. Inside the file specify the package of target class just like if you'd create it.\r\n3. Specify the target class (or enum, or interface) just like if you'd create it.  \r\n_Access modifiers as well as `extends`/`implements` clauses and annotations make no sense to droplets and thus may be omitted. Arbitrary combinations of inner types are supported by jMint._\r\n4. Define the target method just like if you'd create it.  \r\n_Access modifiers as well as `throws` clause and annotations make no sense to droplets and thus may be omitted._\r\n5. Prepend the target method with javadoc description.  \r\n_It's a good practice to write detailed description of modifying method here but the droplet itself requires only one custom javadoc tag - `@cutpoint` followed by one of values: `BEFORE`, `INSTEAD`, `AFTER`._\r\n6. Write the body of the method according to selected cutpoint.  \r\n:warning: _Please remember about some limitations of modifying code (see corresponding section below)._\r\n7. Repeat steps 4-6 for all the methods you'd like to modify and then save the droplet.\r\n\r\n:bulb: **Example.** Here's a sample droplet created from scratch (_FooDroplet.java_):\r\n```java\r\npackage com.example.coolapp;\r\n\r\nimport com.example.coolapp.model.BusinessEntity;\r\n\r\nclass FooDroplet {\r\n  /** @cutpoint BEFORE */\r\n  void fooify(BusinessEntity entity) {\r\n    System.out.println(\"Entity to fooify: \" + entity.toString());\r\n  }\r\n}\r\n```\r\nWriting such droplet might took some time but it is free of redundancy inherent to the first approach.\r\n***\r\n\r\n## Step 2: Attach jMint to the app\r\nBecause jMint ships as Java agent, it is attached to JVM through its startup argument `-javaagent`. The absolute or relative path to jMint jar is specified after colon (`:`) following the argument name. Then, followed by equal sign goes a list of droplets paths separated by semicolon (`;`). As a whole the command line may look like:\r\n```bash\r\njava -javaagent:path/to/jmint.jar=a/long/way/to/droplets/FirstDroplet.java;a/long/way/to/droplets/SecondDroplet.java com.example.coolapp.Main\r\n```\r\n:bulb: _To shorten the record you may introduce a couple of variables in the launch script to hold the prefix paths:_\r\n```bash\r\nJMINT_PATH=path/to/jmint.jar\r\nDROPLETS_HOME=a/long/way/to/droplets\r\njava -javaagent:$JMINT_PATH=$DROPLETS_HOME/FirstDroplet.java;$DROPLETS_HOME/SecondDroplet.java com.example.coolapp.Main\r\n```\r\nStarted with such arguments JVM will launch jMint and let it modify byte code of classes being loaded.  \r\n:warning: *Note that being unable to load an agent JVM will not start at all.*  \r\n:information_source: *`javaagent` is not singleton option for JVM. You may add as many agents as you want declaring them as separate  `javaagent` arguments on the JVM launch command.*  \r\nTo ensure that your target methods have been modified correctly look for messages from class `tech.toparvion.jmint.TargetsTransformer` in the log (see _Logging_ section).\r\n\r\n# Limitations\r\nUnfortunately, source code of droplets' methods (the modifying code) can not be as rich and diverse as usual one.\r\nThe modifying code must not contain:\r\n- anonymous classes (including lambdas);\r\n- array initializers, a comma-separated list of expressions enclosed by braces { and } unless the array dimension is one;\r\n- labeled continue and break statements;\r\n- references to generic type parameters (like T in method `T <T> nvl(T t)`);\r\n- references to static methods or variables imported on demand (i.e. like `java.lang.Double.*`; it should be replaced with separate single imports);\r\n- _there are likely some other limitations; if you find one please share it with fellow users via Github issues._\r\n\r\nThe reasons explanation is beyond this document; you may see [Limitations](https://jboss-javassist.github.io/javassist/tutorial/tutorial2.html#limit) chapter of Javassist Tutorial for more info.\r\n\r\n# Logging\r\njMint emits some messages about its work to the log using [SLF4J](http://slf4j.org/) logging facade. Therefore the actual logging implementation depends on SLF4J binding present on the application classpath. If there is no binding, jMint emits the only message to standard error output and stays silent till the end:\r\n```\r\nSLF4J: Failed to load class \"org.slf4j.impl.StaticLoggerBinder\".\r\nSLF4J: Defaulting to no-operation (NOP) logger implementation\r\nSLF4J: See http://www.slf4j.org/codes.html#StaticLoggerBinder for further details.\r\n```\r\nHere's some sample messages emitted by jMint when `slf4j-simple` binding is present on the classpath:\r\n```\r\n... (at the start of JVM) ...\r\n[main] INFO tech.toparvion.jmint.JMintAgent - jMint started (version: 1.1).\r\n...\r\n[main] INFO tech.toparvion.jmint.JMintAgent - Droplets loading took: 1167 ms\r\n... (later, at runtime) ...\r\n[main] INFO tech.toparvion.jmint.TargetsTransformer - Method 'sampleapp.standalone.painter.Painter.buildContent()' has been modified at AFTER cutpoint.\r\n...\r\n[main] INFO tech.toparvion.jmint.TargetsTransformer - Method 'sampleapp.standalone.painter.Painter#main' is skipped due to IGNORE cutpoint.\r\n```\r\n\r\n# Under the hood\r\njMint is built upon three other tools: Java Byte Code Instrumentation API, Javassist byte code manipulating library and ANTLR4 language recognition tool. The latter (created by professor of genius Terence Parr (@parrt)) is used by jMint during startup to parse droplets and extract all the required information from them. Then with the help of Instrumentation API jMint registers itself as an interceptor for all the class loadings happening in JVM. When loading of some target class is detected jMint transforms its byte code by means of Javassist library (created by incredibly talented Shigeru Chiba (@chibash)) and returns it back to JVM.\r\n\r\n# License\r\njMint is distributed under MIT License (see [LICENSE.txt](https://github.com/Toparvion/jmint/blob/master/LICENSE.txt)).\r\n\r\n# Support & feedback\r\njMint is being developed by single person (@Toparvion) in free time as a helpful tool for day-to-day tasks. It is not finished yet so that new features (alongside with bug fixes) are expected in the foreseeable future. The priorities in choosing features to implement (and bugs to fix) depend heavily on the feedback going from the tool's users. You're welcome to post [issues](https://github.com/Toparvion/jmint/issues) or contact the author directly: `toparvion[at]gmx[dot]com`. Testing assistance is extremely appreciated:wink:\r\n",
  "note": "Don't delete this file! It's used internally to help with page regeneration."
}